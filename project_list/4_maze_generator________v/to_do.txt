1.~~~_plus 함수에서 상하좌우 각 경우를 함수포인터를 통해 함수로 분할할 것
2.~~~_plus 함수에서 사면고립시에 작동하는 함수 따로 분할할 것
//---------완료 근데 딱히 눈에 띄게 좋지도 않다. 100줄 줄어들 줄 알고 했는데 고작 10줄 줄였다

3.프로그램 가동 결과 생성되는 미로를 저장, 불러오는 방법 찾아내서 구상할 것
4.출구까지 경로 찾는 프로그램 제작
  ㄱ.수거 메커니즘
    a.미로 제작 시 모든 통로에 path=1값 전부 부여되어있음
    b.입구,출구를 제외한 모든 막다른길(삼면으로 막힌 길)에 수거 시드를 부여
    c.수거 시드에 부여된 곳에 수거 체인을 건다.
    d.이를 반복하다가 갈림길을 만나게 되면 수거 종료
    #이때, path값이 0으로 이미 수거된 길은 갈림길로 치지 않는다.
    e.이러한 시행의 결과 입구와 출구만 연결된 통로만이 path=1값을 가지게 될 것
    f.전체에 path값 스캔을 해서 경로를 보여준다
  ㄴ.값 비교 메커니즘
    a.void_chain 재활용을 위해 전체 path값 0으로 청소
    b.입구에 find_seed 부여 및 find_chain 부여  //find 함수는 void 함수를 조금 변형시켜서 재활용 하면 된다.
      #이때,find_chain을 건쪽의 find 값이 n이라면, find_chain을 받은 쪽의 find값에 n+1을 부여한다.
    d.이런 식으로 출구까지 도달하게 만들어서, 출구까지 도달하게 된다면 모든 체인을 중지시킨다.//함수 연쇄반응일텐데 어떻게 싹 중지시킬지는 모르겠다
    e.출구에 find 수거 시드 부여 및 수거 체인 부여
      # 이때, 수거 체인을 받는 블럭은 체인을 주는 블럭의 find값보다 하나 작아야 수거받을 수 있다.
    f.find값이 0 또는 1(시작점의 find값)에 도달하게 되면, 수거한 블럭들의 경로는 입구와 출구 사이의 통로이다.
    g.전체에 수거된값을 가진 블럭을 스캔해 경로를 보여준다.
-----------------------
미로의 크기가 크다면 값 비교 메커니즘이 더욱 효과적일 것이다.
반면 미로의 크기가 작다면 수거 메커니즘이 더욱 효과적일 것이다.
뇌피셜이다 아니면 말고
생각해보니 그냥 값 비교 메커니즘이 수거보다는 효과적일 것 같다.
